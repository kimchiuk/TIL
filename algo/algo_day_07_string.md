# 패턴 매칭

- 패턴 매칭에 사용되는 알고리즘들
  - 고지식한 패턴 검색 알고리즘
    
  - 카프-라빈 알고리즘
    
  - kmp 알고리즘
    
  - 보이어-무어 알고리즘
    
## 고지식한 알고리즘

- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
![img_6.png](img_6.png)
```python

p = 'is' # 찾을 패턴
t = 'This is a book~!'
M = len(p)   # 찾을 패턴의 길이
N = len(t)   # 전체 텍스트의 길이

def BruteForce(p, t):
    i = 0   # t 의 인덱스
    j = 0   # p 의 인덱스
    while j < M and i < N:
        if t[i] != p[j]:
            i = i - j
            j = -1
        i = i + 1
        j = j + 1
    if j == M:
        return i - M  # 검색 성공
    else:
        return -1   # 검색 실패

# while -> for 문
def BruteForce(p, t):
    for i in range(N - M + 1):
        for j in range(M):
            # 패턴 매칭
            if t[i + j] != p[j]:
                break
        else:
            # 검색 성공
            return i  # t 인덱스 반환
        
    # 검색 실패
    return -1

```

- 고지식한 패턴 검색 알고리즘의 시간 복잡도
  - 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨
  - 길이가 10000인 문자열에서는 길이 80인 패턴을 찾는다고 할 때, 최악의 경우 약 10,000*80 = 800,000 번의 비교가 일어난다.
  - 비교횟수를 줄일 수 있는 방법은 없는가?
    
## KMP 알고리즘

- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행

- 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
  - next[M]: 불일치가 발생했을 경우 이동할 다음 위치
    
- 시간 복잡도: O(M+N)

- 아이디어 설명
  - 텍스트에서 abcabc 까지는 매치되고, e에서 실패한 상황 패턴의 맨 앞의 abc 와 실패 작전의 abc 는 동일함을 이용할 수 있다.
    
  - 실패한 텍스트 문자와 P[4]를 비교한다.
    ![img.png](img.png)
    
  - 매칭이 실패했을 때 돌아갈 곳을 계산한다
    ![img_1.png](img_1.png)
    
## 보이어-무어 알고리즘

- 오른쪽에서 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 된다.
![img_2.png](img_2.png)
  
- 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우
![img_3.png](img_3.png)
  
- 보이어-무어 알고리즘을 이용한 예
![img_4.png](img_4.png)
  
  - rithm 문자열의 skip 배열
    ![img_5.png](img_5.png)
    
- 문자열 매칭 알고리즘 비교
  - 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
  - 고지식한 패턴 검색 알고리즘: 수행시간 O(mn)
  - 카프-라빈 알고리즘: 수행시간 O(n)  (항상)
  - KMP 알고리즘: 수행시간 O(n)  (항상)

- 보이어-무어 알고리즘
  - 앞의 두 매칭 알고리즘들의 공통점 텍스트 문자열의 문자를 적어도 한번씩 훑는다는 것이다. 따라서 최선의 경우에도 O(n)
  - 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다.
  - 발상의 전환: 패턴의 오른쪽부터 비교한다.
  - 최악의 경우 수행시간: O(mn)
    
  - 입력에 따라 다르지만 일반적으로 O(n)보다 시간이 덜 든다.
    
# [참고] 문자열 암호화

- 시저 암호(Caesar cipher)
  - 줄리어스 시저가 사용했다고 하는 암호이다.
  - 시저는 기원전 100년경에 로마에서 활약했던 장군이었다.
  - 시저 암호에서는 평문에서 사용되고 있는 알파벳을 일정한 문자 수 만큼 [평행이동] 시킴으로써 암호화를 행한다.
  
- 1 만큼 평행했다는 카이사르 암호화의 예

평문 save p

- 1 만큼 평행했을 때 1을 키값이라 한다.
- 수신자 이외에 사람(키가 1이라는 사실을 모르는 사람)이 암호문 TBWFAQSJWBUFASZBO을 보고 다른 정보없이도 

- 시저 암호문에 대한 전사공격

- 문자 변환표를 이용한 암호화(단일 치환 암호)
  - 단순한 카이사르 암호화보다 훨씬 강력한 암호화 기법
  
  - 문자 변환표의 예
  ![img_9.png](img_9.png)
  - 위 변환표를 사용한 암호화의 예
  ![img_10.png](img_10.png)
  - 단일 치환 암호의 복호화
    - 복호화 하기 위해서는 모든 키의 조합(key space)가 필요하다.
  - 단일 치환 암호의 키의 총수는
    - 26 x 25 x 24 x 23 x ... x 1 = 26! = 40329.......
  - 1초에 10억 개의 키를 적용하는 속도로 조사한다고 해도, 모든 키를 조사하는 데 120억년 이상의 시간이 걸린다. 방법이 없을까? 있다! 관심있으면 찾아보길
  
- bit 열의 암호화
  - 배타적 논리합(exclusive-or) 연산 사용
  ![img_8.png](img_8.png)
- 다음과 같은 문자열이 있따. 저장소의 크기를 줄이며 정확한 정보를 저장하는 방법은?
  - Run-length encoding 알고리즘
  - 같은 값이 몇 번 반복되는가를 나타냄으로써 압축
  ![img_7.png](img_7.png)
  - 이 방법은 이미지 파일포맷 중 BMP 파일 포맷의 압축 방법이다.
  - 좀 더 효율적이고 일반적인 압축방법은 없는가?
    - 있다. 많이 사용하는 알고리즘으로 허프만 코딩 알고리즘이 있다.
  

