# Computational Thinking (기초 논리 & 수학)

- 프로그래밍의 어려운점 두 가지
  - 프로그래밍 언어 문법과 라이브러리 사용
  - 논리(hard logic)
    
- 문법과 라이브러리
  - 많이 알려진 어려운 점
  - 위 프로그램이 무엇인지 처음 보는 사람은 알 수 없음
    
## 프로그래밍과 논리/수학
- 논리
  - hard vs. soft logic
  - 카드 문제
  - 사실: 모든 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써있음
  - 주장: 한쪽이 D 이면 반대쪽은 3
  - 주장이 사실인지 확인하기 위해 다음 카드 중 반드시 뒤집어 보아야 하는 것은 몇 개 이고 어느 것인가?
    
    D F 3 7

## 참고
- 명제
  - 참이나 거짓을 알 수 있는 식이나 문장
  - p, q, r, .. 로 표현
    예) 서울은 수도이다.
    1 + 1 = 3
    
- 진리값
  - 참이나 거짓을 표현
  - T, F 또는 1, 0
    
- 연산 (결합)
  - 부정 not
    - p가 명제일 때, 명제의 진릿값이 반대
    - ~p 또는 ㄱp로 표기 (not p 또는 p의 부정으로 읽음)
    
- 논리곱 AND
  - p, q 가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
  - p ^ q (p and q, p 그리고 q)
    
- 논리합 or
  - p, q가 명제일 떄, p, q 중 하나만 참일 때 참이 되는 명제
  - p V q (p or q, p 또는 q)
    
- 배타적 논리합 XOR
  - p, q가 명제일 때, p,q 중 하나만 참일 때 참이되는 명제
  - p xor q

- 연산자 우선순위
  - ㄱ > V, ＾ > ->, <-
  - 항진명제: 진리값이 항상 참
  - 모순명제: 진리값이 항상 거짓
  - 사건명제: 항진명제도 모순명제도 아닌 명제

- 조건명제
  - p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
  - p -> q (p이면 q이다.)
    T F -> F    

- 쌍방 조건명제
  - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
  - p <-> q (p면 q고, p면 q다.)
    
- 조건명제의 역, 이, 대우
  - 역: q -> p
  - 이: ~p -> ~q
  - 대우: ~q -> ~p
    
- 증명
  - 증명은 명확한 명제식으로 표현할 수 있는 것이라야 함
  - 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
  - 증명에 대한 수많은 오해가 p -> q를 p <-> q와 혼동하는 것에서 일어남

## 수와 표현
약간의 설명
- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k-1까지 표현 가능
- 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 어떤 경우든 최대 2^k 가지의 값을 표현하는 것이 가능
- 10진수로 k자리를 쓰면 0부터 10^k-1까지 표현이 가능한 것과 완전히 동일한 과정

- 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
- 2^k - 1 >= n이 성립해야 함 -> 즉, 2^k >= n+1
- 같은 의미로, k >= log(n+1) -> 약 log n 비트가 필요
- x = log n과 2^x = n 은 같은 말

- log n이란
  (가) 2의 몇 승이 n이 되느냐의 답
  (나) n을 표현하는 데 몇 비트가 필요한가의 답
  (다) 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 값
  (라) n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답 
  
- x = log N 일 때 x와 n을 비교하면 x가 더 작고, n이 커질수록 엄청나게 달라진다.
- 100자리로 표현할 수 있는 10진수 값은 읽을 수 없을 정도로 큰 값이다.
- 컴퓨터 분야에서 로그의 밑은 항상 2

- 32비트 컴퓨터의 주소공간은 2^32 = 약 40억개 주소
- n + (n/2 + n/2) + (n/4 + n/4 + n/4 + n/4) + ... + (1 + 1 + ..) = nlog n
- n + n/2 + n/4 + ... + 1 = (약) 2n
- 위 두 식의 항의 개수는 log n 개 

# 재귀
약간의 설명
- 재귀란 자기 자신을 호출하는 함수, 그럼 끝날 수 있는가?
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음
- 하지만, 다른 입력으로 호출하면 끝날 수 있음

- 함수란 어떤 문제를 해결하는 방법을 코딩한 것
- 함수가 어떤 문제의 단 한 케이스만을 해결하는 것이 아님
- 제대로 코딩 된 것이라면 해결하는 문제의 모든 케이스를 해결해야 함

- 수학적 귀납법 증명 사용 가능
  (가) n이 0일 때 문제를 풀 수 있음
  (나) n-1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있다.
- 위 두 가지가 사실이면 모든 가능한 n에 대해 문제를 풀 수 있다는 것이 사실

- 어떤 미스터리한 이유로 문제가 해결되는 것은 아니고, 실제로 프로그램을 돌리면 필요한 계산이다. 순차적인 코드에서 일어나는 계산과 완전히 동일. 다만 표현하는 방법이 달라진 것

- 다르게 생각하는 방법: 어떤 문제를 해결하려다가 부분 문제를 만났는데, 원래 해결 하려던 입력 케이스와 동일한 문제에 속하지만 "크기가 더 작은" 입력 케이스를 해결하는 것이 그 부분 문제였다.!
- 즉, 부분 문제가 동일한 문제인 경우!

# 동적 프로그래밍
약간의 설명
- 간단하게 설명하면 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과값을 저장해두고 불러 쓰는 것이다. (memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다.
- 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과 값을 순서를 정해서 계산할 수도 있다. (dynamic programming)
