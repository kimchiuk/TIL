# 조합
- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합이라고 부른다.
- 조합의 수식
nCr = n! / (n-r)!r!, (n >= r)
nCr = n-1Cr-1 + n-1Cr       - 재귀적 표현
nC0 = 1
  
- 재귀 호출을 이용한 조합 생성 알고리즘
```
an[] : n개의 원소를 가지고 있는 배열
tr[] : r개의 크기의 배열, 조합이 임시 저장될 배열

comb(n, r):
    if (r == 0) print_arr()
    else if (n < r) return
    else
        tr[r-1] = an[n-1]
        comb(n-1, r-1)
        comb(n-1, r)
```

## 참고
- 10개의 원소 중 3개를 고르는 조합
  - i < j < k 라고 하면,
```
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  # 10개의 원소 n, 3개의 조합 r
for i : 0 -> 7              # j, k 로 선택될 원소를 남김
    for j : i + 1 -> 8      # k로 선택될 원소를 남김
        for k : j + 1 -> 9
            f(a[i], a[j], a[k])
```
  - n개에서 r개를 고르는 조합(재귀)
```
a = [0, 1, 2, ..., n-r, n-(r-1), ..., n-3, n-2, n-1]   # 총 n개
def nCr(n, r, s):   # n개에서 r개를 고르는 조합, s 선택할 수 있는 구간의 시작
    if r == 0:
        print(*comb)
    else:
        for i in range(s, n-r+1):
            comb[r-1] = A[i]
            nCr(n, r-1, i+1)
```

## 연습문제 3
- 부분집합 합 문제 구현하기
  - 아래 10개의 정수 집합에 대한 모든 부분 집합중 원소의 합이 0이 되는 부분 집합을 모두 출력하시오
    

# 탐욕 알고리즘
- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.

- 여러 경우 중 하나를 선택 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.

- 일단, 한번 선택된 것은 번복하지 않는다. 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다.
- 최적화 문제란 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.

## 탐욕 알고리즘의 동작 과정
1) 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
2) 실행 가능성 검사: 새로운 부분 해 집합이 실행가능한지를 확인한다.
  곧, 문제의 제약 조건을 위반하지 않는 지를 검사한다.
3) 해 검사: 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

## 탐욕 알고리즘의 필수 요소
- 탐욕적 선택 속성
  - 탐욕적 선택은 최적해로 갈 수 있음을 보여라.
    -> 즉, 탐욕적 선택은 항상 안전하다.
    
- 최적 부분 구조
  - 최적화 문제를 정형화하라
    -> 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
    
- **[원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해]** 임을 증명하라.
